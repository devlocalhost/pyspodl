#!/usr/bin/python3

"""
pyspodl - a spotify downloader using librespot
"""

import os
import sys
import time
import base64

import tqdm
import toml
import requests

from mutagen.flac import Picture
from mutagen.oggvorbis import OggVorbis

from mutagen.oggvorbis import OggVorbisHeaderError
from mutagen.ogg import error

from librespot.core import Session
from librespot.metadata import TrackId
from librespot.audio.decoders import AudioQuality, VorbisOnlyAudioQuality

from arguments import get_arguments


class ConfigError(Exception):
    """
    triggered when theres an issue with the config file
    """


class Config:
    """
    config related functions
    """

    def __init__(self, config_path=None):
        self.config_file = os.path.abspath(config_path) if config_path else os.path.abspath("config.toml")

    def __str__(self):
        return f"[Config] Using file {self.config_file}"


    def read_config(self):
        """
        read the config file and return the data
        """

        try:
            with open(self.config_file, encoding="utf-8") as config_file:
                return toml.load(config_file)

        except FileNotFoundError:
            sys.exit(f'[read_config] Config file "{config_path}" not found.')


    def get_config_value(self, section, key):
        """
        get value from config file
        """

        config = self.read_config()
        value = config.get(section).get(key)

        if value is None or (isinstance(value, str) and not value.strip()):
            raise ConfigError(
                f"[get_config_value] Value for '{key}' in section '{section}' is missing or blank."
            )

        return value

class Utils:
    def generate_new_token():
        """
        tokens are not permament, they expire after an hour,
        so when invalid, regenerates a new one
        """

        client_id = get_config_value("account", "client_id")
        client_secret = get_config_value("account", "client_secret")

        resp = requests.post(
            "https://accounts.spotify.com/api/token",
            {
                "grant_type": "client_credentials",
                "client_id": client_id,
                "client_secret": client_secret,
            },
            timeout=10,
        ).json()

        config = read_config()

        if config:
            config["account"]["token"] = resp["access_token"]

            try:
                with open("config.toml", "w", encoding="utf-8") as f:
                    toml.dump(config, f)

            except Exception as e:
                sys.exit(
                    f"[generate_new_token] Error updating the configuration file: {e}\n\nManually update token from the config.toml file by yourself with: \"{resp['access_token']}\""
                )

        try:
            os.execv(sys.argv[0], sys.argv)

        except FileNotFoundError:
            sys.exit("Token was updated, run pyspodl again")


    def get_token():
        """
        gets the temporary saved token from the config file
        """

        try:
            token = get_config_value("account", "token")

        except ConfigError:
            generate_new_token()

        headers = {"Authorization": f"Bearer {token}"}
        resp = requests.get(
            "https://api.spotify.com/v1/search?q=home+resonance&type=track",
            headers=headers,
            timeout=10,
        )

        if resp.status_code == 401:
            generate_new_token()

        return token


    def set_metadata(metadata, cover_image, filename):
        """
        set metadata to a file (these are ogg tags, not id3!)
        """

        file = OggVorbis(f"{filename}.ogg")

        for key, value in metadata.items():
            file[key] = str(value)

        try:
            resp = requests.get(cover_image["url"], timeout=10)
            picture = Picture()

            picture.data = resp.content
            picture.type = 17
            picture.mime = "image/jpeg"
            picture.width = cover_image["width"]
            picture.height = cover_image["height"]

            picture_data = picture.write()
            encoded_data = base64.b64encode(picture_data)
            vcomment_value = encoded_data.decode("ascii")

            file["metadata_block_picture"] = [vcomment_value]

        except requests.exceptions.RequestException:
            pass

        try:
            file.save()

        except (OggVorbisHeaderError, error):
            pass  # fuck you
            # seriously fuck it, idk why it happens


def get_session():
    """
    create a user session and return it
    """

    try:
        print("[get_session] Trying to create a session...")

        session = (
            Session.Builder()
            .user_pass(
                get_config_value("account", "email"),
                get_config_value("account", "password"),
            )
            .create()
        )

        return session

    except Exception as exc:
        sys.exit(
            f"[get_session] An issue occured while trying to create session:\n{exc}"
        )


def get_id_type_from_url(url):
    """
    get the id of the track or whatever, and the type of whatever (lol.)
    """

    return (url.split("/")[4].split("?")[0], url.split("/")[3])


class Downloader:
    """
    where the magic happens.
    """

    def __init__(self, config):
        """
        define some values i guess...?
        """

        self.session = get_session()

        self.premium_downloads = config.get_config_value("downloading", "premium_downloads")
        self.download_path = config.get_config_value("downloading", "download_path")
        self.set_metadata = config.get_config_value("downloading", "set_metadata")

    def __str__(self):
        return f"Premium? {self.premium_downloads}, Download path? {self.download_path}, Metadata? {self.set_metadata}"

    def get_track_urls(self, link):
        """
        get all tracks available in a playlist or album (spotify gives max 50 entries)
        """

        track_urls = []
        offset = 0
        limit = 100
        id_from_url = get_id_type_from_url(link)

        url = (
            f"https://api.spotify.com/v1/{id_from_url[1] + 's'}/{id_from_url[0]}/tracks"
        )

        while True:
            try:
                headers = {"Authorization": f"Bearer {get_token()}"}
                params = {"offset": offset, "limit": limit}

                response = requests.get(url, headers=headers, params=params, timeout=10)
                items = response.json().get("items", [])

                if not items:
                    break

                track_urls.extend(
                    # item["track"]["id"]
                    item["track"]["external_urls"]["spotify"]
                    for item in items
                    if "track" in item and item["track"]
                )

                offset += limit

            except requests.exceptions.RequestException as e:
                print(f"[get_track_urls] Error making request: {e}")
                break

        return track_urls

    def download_playlist_or_album(self, link):
        """
        download songs off an album or playlist
        """

        tracks = self.get_track_urls(link)

        for track in tracks:
            self.download_track(track)  # sends id

    def download_track(self, url):
        """
        download an track
        """

        try:
            timeout = get_config_value("downloading", "timeout")

            print(f"[download_track] Sleeping for {timeout} seconds...")

            time.sleep(timeout)

        except TypeError:
            sys.exit(
                '[download_playlist_or_album] "timeout" from config file must be a number (without quotes).'
            )

        track_id = TrackId.from_uri(f"spotify:track:{get_id_type_from_url(url)[0]}")
        headers = {"Authorization": f"Bearer {get_token()}"}

        resp = requests.get(
            f"https://api.spotify.com/v1/tracks/{get_id_type_from_url(url)[0]}",
            headers=headers,
            timeout=10,
        ).json()

        artist = resp["artists"][0]["name"]  # artist
        track_title = resp["name"]  # title
        album_name = resp["album"]["name"]  # album
        album_release = resp["album"]["release_date"]  # date
        track_number = resp["track_number"]  # tracknumber
        cover_image = resp["album"]["images"][0]  # coverart, width, height

        if self.premium_downloads:
            stream = self.session.content_feeder().load(
                track_id, VorbisOnlyAudioQuality(AudioQuality.VERY_HIGH), False, None
            )

        else:
            stream = self.session.content_feeder().load(
                track_id, VorbisOnlyAudioQuality(AudioQuality.HIGH), False, None
            )

        filename_format = get_config_value("downloading", "track_format")
        filename = filename_format.format(
            artist=artist,
            title=track_title,
            album=album_name,
            tracknumber=track_number,
            year=album_release,
        )

        print(f"Downloading {track_title} by {artist}")

        path_filename = f"{self.download_path}/{filename}"

        if os.path.exists(path_filename + ".ogg"):
            print("Track exists, skipping")

        else:
            directory_path = os.path.dirname(path_filename)

            if directory_path and not os.path.exists(directory_path):
                os.makedirs(directory_path)

            with open(f"{path_filename}.ogg", "wb+") as track_file, tqdm.tqdm(
                unit="B",
                unit_scale=True,
                unit_divisor=1024,
                total=stream.input_stream.size,
                bar_format="{percentage:3.0f}%|{bar:16}|{n_fmt} / {total_fmt} | {rate_fmt}, ETA {remaining}",
            ) as progress_bar:
                for _ in range(int(stream.input_stream.size / 5000) + 1):
                    progress_bar.update(
                        track_file.write(stream.input_stream.stream().read(50000))
                    )

            if self.set_metadata:
                tags = {
                    "artist": artist,
                    "title": track_title,
                    "album": album_name,
                    "date": album_release,  # .split("-")[0],
                    "tracknumber": track_number,
                }

                set_metadata(tags, cover_image, path_filename)

    def download(self, link):
        """
        execute the function based on the link
        """

        link_type = get_id_type_from_url(link)[1]

        if link_type == "track":
            self.download_track(link)

        elif link_type in ("album", "playlist"):
            self.download_playlist_or_album(link)

        else:
            sys.exit('[download] Invalid URL. URL must start with "open.spotify.com"')


if __name__ == "__main__":
    arguments = get_arguments()
    config = Config()
    downloader = Downloader(config)

    sys.exit([arguments, config.__str__(), downloader.__str__()])
